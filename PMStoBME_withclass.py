import math
from functools import reduce
import re
import random
import os
import sys
import io
from classtest import Channel
from pathlib import Path

def lcm(denominators):
    '''Function to calculate Least Common multiple'''
    return reduce(lambda a, b: a * b // math.gcd(a, b), denominators)

#  Function that determines if a string contains only zeroes
def is_only_zeroes(string):
    charRe = re.compile(r'[^0]')
    string = charRe.search(string)
    return not bool(string)

def determine_background_track(chartfile: str) -> str:
    '''Returns largest wav file in song directory (background track)'''
    directory = chartfile.rsplit(sep='/', maxsplit=1)[0]
    bg_track = 'ZY' # Default to ZY since ZZ sometimes isused  for long notes
    maxsize = 0
    for subdir, dirs, files in os.walk(directory):
                for file in files:
                    if file.endswith('.wav') and not file.startswith('preview'):
                        path = os.path.join(subdir, file)
                        size = os.stat(path).st_size # in bytes
                        if size > maxsize:
                            maxsize = size
                            bg_track = file.rsplit(sep='.wav')[0]
    return bg_track

def clean_chart(input_chart : list[str]) -> list[str]:
    '''Strips trailing whitespace from each line of the input chart'''
    cleaned_chart = list()
    for element in input_chart:
        cleaned_chart.append(element.strip())
    return cleaned_chart

def identify_start_position(input_chart : list[str]) -> int:
    '''Returns the position in the file of the first measure in the chart
       This is right after "MAIN DATA FIELD" in BME/PMS files generated by
       iBMSC.
    '''
    chart_start = 0
    for line in input_chart:
        matched = re.search(r'#00\d\d\d:', line)
        if matched:
            break
        else:
            chart_start+= 1
    return chart_start

def process_header_info(header : list[str]) -> list[str]:
    '''Simplifies header info by discarding some problematic fields'''
    comment = '#COMMENT.*'
    genre = '#GENRE.*'
    title = '#TITLE.*'
    artist = '#ARTIST.*'
    strings = [comment, genre, title, artist]
    try:
        index_player_var = header.index('#PLAYER 3')
        header[index_player_var] = ('#PLAYER 1')
    except ValueError:
        print(f'#PLAYER 3 tag not found in header, skipping')
    
    for element in strings:
        index = [i for i in range(len(header)) if re.match(element, 
                header[i], flags=re.IGNORECASE)]
        if index:
            header[index[0]] = ''

    return header

def calculate_lcm(chart) -> int:
    divisions = []
    for line in chart:
        multiple = int(len(line[7:])/2)
        if not(multiple in divisions):
            divisions.append(multiple)
    try:
        divisions.remove(0) # remove 0 to avoid errors
    except ValueError:
        pass
    LCM = lcm(divisions)
    if LCM > 2000:
        while (LCM > 200):
            LCM //= 2
        print(f'WARNING: LCM had to be capped at {LCM}')
    if LCM < 48:
        LCM = LCM * 4
        print(f'WARNING: LCM was increased to {LCM}')
    return LCM

def calculate_Sfree(LCM, T_MIN, songBPM) -> int:
    t_lcm = (60/songBPM)*4/LCM
    Sfree = math.ceil(T_MIN/t_lcm)
    return Sfree

def extract_measure_changes(input_chart):
    MCBPM02 = []
    for ind, line in enumerate(input_chart):
        if line[4:6] == '02':
            MCBPM02.append(line)
    return MCBPM02

def pad_chart_with_zeroes(input_chart, hidden_channels, LCM):
    '''Pads input chart with zeroes according to LCM. Ignores channels 
       specified in hidden_channels.
    '''
    padded_chart = []
    for ind, line in enumerate(input_chart):
        if hidden_channels.count(line[4:6]): 
            continue # remove lines that contain useless notes
        linelist = re.findall('..?', line[7:]) # parses string into list of 2-char strings
        paddedline = ''.zfill(LCM * 2)
        paddedlinelist = re.findall('..?', paddedline)
        for samplepos, sample in enumerate(linelist):
            paddedlinelist[samplepos * LCM // len(linelist)] = sample
        line = line[:7] + ''.join(paddedlinelist)
        padded_chart.append(line)
    return padded_chart

def fill_master_channels(chart : list[str], MCc, MCBGs_list, LCM : int) -> None:
    for ind, line in enumerate(chart):
            linelist = re.findall('..?', line[7:])
            measure = int(line[1:4])
            if line[4:6] != '01': # '01' corresponds to background samples
                for samplepos, sample in enumerate(linelist):
                    MCc[line[4:6]].modify_sample(measure * LCM + samplepos, sample)
            else:
                #Fill MCBGs with background samples of PopN chart
                for samplepos, sample in enumerate(linelist):
                    if sample != '00':
                        position = measure * LCM + samplepos
                        for MCBG in MCBGs_list:
                            if MCBG.read_sample(position) == '00':
                                MCBG.modify_sample(position, sample)
                                break
                        else: #no break
                            print(f'WARNING: Could not find free BG track for sample {sample} at measure {measure}')
    return

def winning_config(LCM: int, measure: int, MCc: Channel):
    i = measure * LCM  
    j = (measure + 1) * LCM
    config_1 = MCc['11'].count_non_null_samples(i,j) + \
                MCc['12'].count_non_null_samples(i,j)
    config_3 = MCc['24'].count_non_null_samples(i,j) + \
                MCc['25'].count_non_null_samples(i,j)
    cols_3_and_4 = MCc['13'].count_non_null_samples(i,j) + \
                MCc['14'].count_non_null_samples(i,j)
    cols_6_and_7 = MCc['22'].count_non_null_samples(i,j) + \
                MCc['23'].count_non_null_samples(i,j)

    config_1_tie = config_1 + cols_3_and_4
    config_3_tie = config_3 + cols_6_and_7
    if config_1 > config_3: return 'config_1'
    if config_3 > config_1: return 'config_3'
    if config_1_tie >= config_3_tie: return 'config_1'
    return 'config_3'

#Methods for PotentialMCs
def move_to_last(input_list : list, element : str) -> list:
    input_list.append(input_list.pop(input_list.index(element)))
    return input_list

def move_to_first(input_list : list, element : str) -> list:
    input_list.insert(0, input_list.pop(input_list.index(element)))
    return input_list

def prioritize_MCs(potential_MCs : list, priority_list : list, ) -> list:
    priority_list.reverse()
    for element in priority_list:
        move_to_first(potential_MCs, element) 
    return potential_MCs

#PMS CONVERSION FUNCTION
def convert(
        chartfile, 
        isKichiku: bool=False, 
        songBPM=150, 
        special_values: list=[100,100,100,100,100],
        songname: str='default name'):
    
    old_stdout = sys.stdout
    new_stdout = io.StringIO()
    sys.stdout = new_stdout
    
    try:
        chord_probs = [100,100] + special_values

        if isKichiku:
            print('This is a Kichiku conversion')
        else:
            print(f'This is NOT a Kichiku conversion')

        try:
            with open(chartfile,'rt', encoding='shift-jis') as file:
                entire_chart = file.readlines()
                directory = file.name.rsplit(sep='/', maxsplit=1)[0]
        except:
            with open(chartfile, 'rt', encoding='utf-8') as file:
                entire_chart = file.readlines()
                directory = file.name.rsplit(sep='/', maxsplit=1)[0]

        if isKichiku:
            # songname = chartfile.rsplit(sep='/', maxsplit=1)[1][1:-4].rsplit(sep=' ', maxsplit=1)[0]
            BG_track = 'ZY' # Default to Zy since ZZ sometimes isused  for long notes
            maxsize = 0
            for subdir, dirs, files in os.walk(directory):
                for file in files:
                    if file.endswith('.wav') and not file.startswith('preview'):
                        path = os.path.join(subdir, file)
                        size = os.stat(path).st_size # in bytes
                        if size > maxsize:
                            maxsize = size
                            BG_track = file.rsplit(sep='.wav')[0]
            print(f'Detected background track: {BG_track}')

        Tmin = 0.135 #in milisecconds

        # Remove newline characters from read chart.
        print('Removing trailing spaces and newline characters...')
        entire_chart_clean = []
        for element in entire_chart:
            entire_chart_clean.append(element.strip())

        # Search for position of start of data
        chart_start = 0
        for line in entire_chart_clean:
            matched = re.search(r'#00\d\d\d:', line)
            if matched:
                break
            else:
                chart_start+= 1
        print(f'Main data starts at line {chart_start} in the input file')
        
        #Split list into header and chart
        print('Splitting data from file header...')
        header_orig = entire_chart_clean[:chart_start]
        chart_with_whitespace = entire_chart_clean[chart_start:]

        # Set PLAYER variable to 1 (IIDX SP) and delete GENRE, COMMENT, ARTIST, and TITLE
        # This is done to prevent problems with character encoding
        print('Removing unwanted tags...')
        header = process_header_info(header_orig)

        # Remove empty strings from chart using list comprehension
        print('Removing empty strings from chart...')
        chart = [i for i in chart_with_whitespace if i]

        # Determine total number of measures by jumping to last element in chart and slicing
        # e.g. go from #06525:0000B200 to only '065' to then the integer 65
        total_measures = int(chart[len(chart)-1][1:4]) 
        print('Number of Total Measures:', total_measures)

        # Determine LCM and Sfree
        # LCM is the number of divisions per measure we will use, i.e. number of pairs of characteres, 
        # like 'AE' and '00', and Sfree is the number of divisions that should be '00' before and
        # after a given position to avoid creating obnoxious jacks when adding samples to 
        # columns 1-7, shorthand for 'Sample-free zone'
        # Some songs give LCMs that are way too large to handle. These are capped at up to 2000.
        # Small LCMs are increased to 48 to give Sfree better temporal resolution.
        divisions = []
        for line in chart:
            multiple = int(len(line[7:])/2)
            if not(multiple in divisions):
                divisions.append(multiple)
        try:
            divisions.remove(0) # remove 0 to avoid errors
        except:
            pass
        LCM = lcm(divisions)
        if LCM > 2000:
            while (LCM > 2000):
                LCM //= 2
            print(f'WARNING: LCM had to be capped at {LCM}')    
        elif LCM < 48:
            LCM = LCM * 4
            print(f'WARNING: LCM was increased to {LCM}')
        else: print('The LCM is:', LCM)
        Tlcm = (60/songBPM)*4/LCM
        Sfree = math.ceil(Tmin/Tlcm)
        print(f'Sfree is {Sfree} samples')
        MClen = LCM*(total_measures+1)

        # Create Master Channels (MCs)
        # The Master Channels will be a continuous list of ALL samples (and '00's) in each channel
        # throughout the entire song, where 'channel' in BMS terms is a column or button in a game
        # such as Buttons 1-7 in IIDX and 1-9 in PopN.

        #Define MC background channels:
        (MCBGc1, MCBGc2, MCBGc3, MCBGc4, MCBGc5, MCBGc6, MCBGc7, MCBGc8, MCBGc9, 
            MCBGc10, MCBGc11, MCBGc12, MCBGc13, MCBGc14, MCBGc15) = \
            (Channel(name=f'MCBG{i}',length=MClen,channel='01',lcm=LCM) for i in range(1, 16))

        (MCBG1, MCBG2, MCBG3, MCBG4, MCBG5, MCBG6, MCBG7, MCBG8, MCBG9, MCBG10, 
            MCBG11, MCBG12, MCBG13, MCBG14, MCBG15) = \
            (re.findall('..?',''.zfill(MClen*2)) for i in range(15))
        
        MCBG_aslist = (MCBGc1, MCBGc2, MCBGc3, MCBGc4, MCBGc5, MCBGc6, MCBGc7, MCBGc8, 
                       MCBGc9, MCBGc10, MCBGc11, MCBGc12, MCBGc13, MCBGc14, MCBGc15)

        #Define channels for buttons:
        MC1, MC2, MC3, MC4, MC5, MC6, MC7, MC8, MC9, MCTT = \
            (re.findall('..?',''.zfill(MClen*2)) for i in range(10))

        MCc1 = Channel(name=f'MC1', length=MClen, channel='11', lcm=LCM)
        MCc2 = Channel(name=f'MC2', length=MClen, channel='12', lcm=LCM)
        MCc3 = Channel(name=f'MC3', length=MClen, channel='13', lcm=LCM)
        MCc4 = Channel(name=f'MC4', length=MClen, channel='14', lcm=LCM)
        MCc5 = Channel(name=f'MC5', length=MClen, channel='15', lcm=LCM)
        MCc6 = Channel(name=f'MC6', length=MClen, channel='22', lcm=LCM)
        MCc7 = Channel(name=f'MC7', length=MClen, channel='23', lcm=LCM)
        MCc8 = Channel(name=f'MC8', length=MClen, channel='24', lcm=LCM)
        MCc9 = Channel(name=f'MC9', length=MClen, channel='25', lcm=LCM)
        MCcTT = Channel(name=f'MCTT', length=MClen, channel='16', lcm=LCM)

        #Define final channels for IIDX
        MC1f, MC2f, MC3f, MC4f, MC5f, MC6f, MC7f, MCTTf = \
            (re.findall('..?',''.zfill(MClen*2)) for i in range(8))

        MCc1f = Channel(name=f'MC1f', length=MClen, channel='11', lcm=LCM)
        MCc2f = Channel(name=f'MC2f', length=MClen, channel='12', lcm=LCM)
        MCc3f = Channel(name=f'MC3f', length=MClen, channel='13', lcm=LCM)
        MCc4f = Channel(name=f'MC4f', length=MClen, channel='14', lcm=LCM)
        MCc5f = Channel(name=f'MC5f', length=MClen, channel='15', lcm=LCM)
        MCc6f = Channel(name=f'MC6f', length=MClen, channel='18', lcm=LCM)
        MCc7f = Channel(name=f'MC7f', length=MClen, channel='19', lcm=LCM)
        MCcTTf = Channel(name=f'MCTTf', length=MClen, channel='16', lcm=LCM)

        #Define channels for BPM changes
        MCcBPM03 = Channel(name=f'MCcBPM03', length=MClen, channel='03', lcm=LCM)
        MCcBPM08 = Channel(name=f'MCcBPM08', length=MClen, channel='08', lcm=LCM)

        #Define dictionaries to simplify sample assignment
        MC = {'11': MC1, '12': MC2, '13': MC3, '14': MC4, '15': MC5, '22': MC6, '23': MC7, 
            '24': MC8, '25': MC9, '01': MCBG1, '16': MCTT, '19':MC7, '18':MC6}
        MCc = {
            '11': MCc1, '12': MCc2, '13': MCc3, '14': MCc4, '15': MCc5, '22': MCc6, '23': MCc7, 
            '24': MCc8, '25': MCc9, '01': MCBGc1, '16': MCcTT, '19':MCc7, '18':MCc6,
            '03': MCcBPM03, '08': MCcBPM08,
            }    
        MCf = {'11': MC1f, '12': MC2f, '13': MC3f, '14': MC4f, '15': MC5f, '22': MC6f, '23': MC7f, 
            '01': MCBG1, '16': MCTTf, '19': MC7f, '18': MC6f}
        MCcf = {'11': MCc1f, '12': MCc2f, '13': MCc3f, '14': MCc4f, '15': MCc5f, '22': MCc6f, '23': MCc7f, 
            '01': MCBGc1, '16': MCcTTf, '19': MCc7f, '18': MCc6f}

        MCc_aslist = [MCc1, MCc2, MCc3, MCc4, MCc5, MCc6, MCc7, MCcTT]
        MCcf_aslist = [MCc1f, MCc2f, MCc3f, MCc4f, MCc5f, MCc6f, MCc7f, MCcTTf]

        # MC7 and MC6 are accessable with two different keys in this dict because this 
        # allows the algorithm to either take a PMS file or a BME file as input.

        print('Extracting lines indicating measure size changes, i.e., channel \'02\'')
        MCBPM02 = extract_measure_changes(chart)

        # Pad each line of the chart with zeroes depending on LCM. 
        # Remove unnecessary channels
        print('Padding entire chart with zeroes...')
        HIDDEN_CHANNELS = [
            '31','32','33','34','35','36','37','38','39',
            '41','42','43','44','45','46','47','48','49','04', '02'
            ]
        padded_chart = pad_chart_with_zeroes(chart, HIDDEN_CHANNELS, LCM)
        
        

        print('Filling Master Channels...')
        fill_master_channels(padded_chart, MCc, MCBG_aslist, LCM)

        # divide chart in 'chunks' according to measures
        # count number of samples in columns 1+2, 2+8, 8+9 for each measure
        # decide which of three 'configurations' to be used for that measure
        # adjust sample positions in this measure according to this configuration
        # move samples in the columns that were left out in this measure        

        if not isKichiku:
            for measure in range(total_measures+1):
                s = measure * LCM #start
                e = (measure + 1) *LCM #end
                winner = winning_config(LCM, measure, MCc)
                if winner == 'config_1':     
                    #config 1 wins, assign samples from MC1-7 to final columns 1-7
                    MCc1f.modify_range(s, e, MCc1.read_range(s,e) )
                    MCc2f.modify_range(s, e, MCc2.read_range(s,e) )
                    MCc3f.modify_range(s, e, MCc3.read_range(s,e) )
                    MCc4f.modify_range(s, e, MCc4.read_range(s,e) )
                    MCc5f.modify_range(s, e, MCc5.read_range(s,e) )
                    MCc6f.modify_range(s, e, MCc6.read_range(s,e) )
                    MCc7f.modify_range(s, e, MCc7.read_range(s,e) )
                    # delete samples from these MCs
                    for channel in (MCc1, MCc2, MCc3, MCc4, MCc5, MCc6, MCc7):
                        channel.modify_range(s,e, ['00' for i in range(LCM)] )
                elif winner == 'config_3':
                    #config 3 wins, assign samples from MC3-9 to final columns 1-7
                    MCc1f.modify_range(s, e, MCc3.read_range(s,e) )
                    MCc2f.modify_range(s, e, MCc4.read_range(s,e) )
                    MCc3f.modify_range(s, e, MCc5.read_range(s,e) )
                    MCc4f.modify_range(s, e, MCc6.read_range(s,e) )
                    MCc5f.modify_range(s, e, MCc7.read_range(s,e) )
                    MCc6f.modify_range(s, e, MCc8.read_range(s,e) )
                    MCc7f.modify_range(s, e, MCc9.read_range(s,e) )
                    # delete samples from these MCs
                    for channel in (MCc3, MCc4, MCc5, MCc6, MCc7, MCc8, MCc9):
                        channel.modify_range(s,e, ['00' for i in range(LCM)] )
                else:
                    raise Exception('Unexpected winning configuration')
            print('Measures adjusted and samples deleted from original MCs')

        if isKichiku:
            for measure in range(total_measures+1):
                s = measure * LCM   
                e = s + LCM
                MCc1f.modify_range(s, e, MCc1.read_range(s,e))
                MCc2f.modify_range(s, e, MCc2.read_range(s,e))
                MCc3f.modify_range(s, e, MCc3.read_range(s,e))
                MCc4f.modify_range(s, e, MCc4.read_range(s,e))
                MCc5f.modify_range(s, e, MCc5.read_range(s,e))
                MCc6f.modify_range(s, e, MCc6.read_range(s,e))
                MCc7f.modify_range(s, e, MCc7.read_range(s,e))
                MCcTTf.modify_range(s, e, MCcTT.read_range(s,e))
                

        def moveSample(inputMC: Channel, MCcf, Sfree, button):
            '''
            Move samples from a given input MC while making sure to not create unfair
            jacks depending on the specified Sfree. 
            '''

            for samplepos, sample in enumerate(inputMC.contents):
                if (sample != '00'):
                    potential_MCs = ['11', '12', '13', '14', '15', '22', '23']
                    random.shuffle(potential_MCs)
                    
                    
                    if button == 1:
                        prioritize_MCs(potential_MCs, ['11','12','13'])
                    elif button == 2:
                        prioritize_MCs(potential_MCs, ['12','11','14'])
                    elif button == 8:
                        prioritize_MCs(potential_MCs, ['22','23','14'])
                    elif button == 9:
                        prioritize_MCs(potential_MCs, ['23','22','15'])

                    #  The two following checks are to avoid an uncommon chord combination
                    #  in IIDX (5+6) as much as possible
                    if MCcf['22'].read_sample(samplepos) != '00':
                        move_to_last(potential_MCs, '23')
                        move_to_last(potential_MCs, '15')
                    if MCcf['15'].read_sample(samplepos) != '00':
                        move_to_last(potential_MCs, '14')
                        move_to_last(potential_MCs, '22')

                    start = samplepos - Sfree
                    end = samplepos + 1 + Sfree
                
                    for possiblepos in potential_MCs:
                        if not MCcf[possiblepos].count_non_null_samples(start, end):
                            MCcf[possiblepos].modify_sample(samplepos, sample)
                            inputMC.modify_sample(samplepos, '00')
                            break
            return
            
        def moveSampleBG(inputMC: Channel, MCcf: dict[Channel], Sfree: int, ForbiddenPos):
            '''
            Move samples from a given input MC while making sure to not create unfair
            jacks depending on the specified Sfree. Can use special values to adjust
            the difficulty of the final chart. 
            '''
            ForbiddenPos = []
            for samplepos, sample in enumerate(inputMC.contents):
                if (sample != '00') and ForbiddenPos.count(samplepos):
                    continue # skip this sample if position is forbidden
                if (sample != '00' and sample != 'ZZ' and sample != BG_track):
                    ChordCount = 0
                    potential_MCs = ['11','12','13','14','15','22','23']
                    for possiblepos in potential_MCs:
                        if MCcf[possiblepos].read_sample(samplepos) != '00':
                            ChordCount = ChordCount + 1
                    # Check if samplepos should be added to forbidden list
                    if ChordCount == 0: ChordCount = ChordCount + 1
                    elif ChordCount == 7: ChordCount = 6
                    if random.randint(0,100) > chord_probs[ChordCount]:
                        ForbiddenPos.append(samplepos)
                        continue # skip this sample after rolling random number
                    random.shuffle(potential_MCs)
                    start = samplepos - Sfree
                    end = samplepos + 1 + Sfree
                    for possiblepos in potential_MCs:
                        if not MCcf[possiblepos].count_non_null_samples(start, end):
                            MCcf[possiblepos].modify_sample(samplepos, sample)
                            inputMC.modify_sample(samplepos, '00')
                            break
            return

        if not isKichiku:
            print('Moving remaining samples from MCs 1, 2, 8, and 9...')
            moveSample(MCc1, MCcf, Sfree, 1)
            moveSample(MCc2, MCcf, Sfree, 2)
            moveSample(MCc8, MCcf, Sfree, 8)
            moveSample(MCc9, MCcf, Sfree, 9)
        if isKichiku:
            ForbiddenPos = []
            print('Moving samples from background channels...')
            for mcbg in MCBG_aslist:
                moveSampleBG(mcbg, MCcf, Sfree, ForbiddenPos)

        # Recreate the modified chart with format #XXXYY:ZZZZZZZZZZ using all MCfs

        #final buttons and TT 
        chartbody_aslist = []
        for mcf in (MCcf_aslist):
            chartbody_aslist.append(mcf.convert_to_string())

        #surplus from buttons 1,2,8,9
        if not isKichiku:
            for mcc in (MCc1, MCc2, MCc8, MCc9):
                mcc.channel = '01'
                chartbody_aslist.append(mcc.convert_to_string())
         
        #MCBGs
        for mcbg in MCBG_aslist:
            chartbody_aslist.append(mcbg.convert_to_string())

        #MCBPMs
        for mcbpm in (MCcBPM03, MCcBPM08):
            chartbody_aslist.append(mcbpm.convert_to_string())
        MCBPM02_str = '\n'.join(MCBPM02)

        #Create Chart
        #After the chart is created, open it in iBMSC and save it immediately. 
        #This will correct the ordering and simplify the formatting of the .bme file.

        converted_chart = '\n'.join(header) + '\n'.join(chartbody_aslist) + MCBPM02_str

        print('Chart created successfully. Writing to file...')
        original_path = Path(chartfile)        
        
        # outfolder = chartfile.rsplit('\\',maxsplit=1)  #TODO fix this using pathlib or smth
        # outfolder[0] = outfolder[0]+'/'

        if isKichiku:
            difficulty = 'leggendaria'
        else:
            difficulty = 'another'

        output_file_name = f'[{songname} {difficulty}.bme'
        new_path : Path
        new_path = original_path.parent / output_file_name

        if new_path.exists():
            os.remove(new_path)
            print(f'WARNING: Previously existing Output Chart file deleted')
        
            
        with open(new_path,'w', encoding='utf-8') as outputfile:
            outputfile.write(converted_chart)
        print('File written to:')
        print(new_path.parent)
        print(new_path.name)
        print('Job complete!')

        log = new_stdout.getvalue()
        sys.stdout = old_stdout
        return log
    except Exception as error:
        print('ERROR!!')
        print(error)
        log = new_stdout.getvalue()
        sys.stdout = old_stdout
        return log
    
def main() -> None:
    testchart_file = r"C:\GamesC\PopNMusicPMSC\PNM22\[hiumi22] illumina\hiumi22 [EXTRA]-ex.pms"
    log = convert(
        chartfile = testchart_file, 
        songBPM = 300, 
        isKichiku = False, 
        songname = 'ilumina test',
        )
    print(log)

if __name__ == '__main__':
    main()